// Q1. 문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요.

function solution(s) {
  var answer = parseInt(s);
  return answer;
}

// Q2. 자연수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요.

function solution(n) {
  var answer = 0;
  for (let i = 1; i <= n; i++) {
    if (n % i === 0) {
      answer += i;
    }
  }
  return answer;
}

// Q3. 정수 num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하는 함수, solution을 완성해주세요.

function solution(num) {
  var answer = num % 2 === 0 ? 'Even' : 'Odd';
  return answer;
}

// Q4. 정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.

function solution(arr) {
  var answer = 0;
  for (let i = 0; i < arr.length; i++) {
    answer += arr[i];
  }
  return answer / arr.length;
}

// ------------------ Fundamental Study ------------------

// # 프로그래밍이란?
// 컴퓨터에 명령을 전달하는 커뮤니케이션으로서 순서에 맞게 문제 해결 과정을 단순하게 분해하고 배열하는 행위를 말한다.

// 즉 문제를 해결하는 능력과 논리적, 수학적 사고가 필요한다.

// ------------------
// # 자바스크립트란?
// Programming Language

// 컴퓨터로 명령을 전달하는 방식은 컴파일러와 인터프리터 방식이 있다. 이것을 사람이 이해 할 수 있는 syntax (문법)을 기계어로 변환하는 번역기에 역할을 한다.

// Syntax & Semantics

// 문제 해결은 프로그램 언어의 문법을 통해 표현된다.

// ------------------
// # 변수
// = 값을 저장할 수 있는 메모리 공간 자체에 붙인 이름을 말한다.
// -	자바스크립트는 동적 언어로 할당할 때 변수에 타입이 정해짐 / 정적은 선언할 때 타입이 정해짐
// -	메모리에 사용 크기는 데이터 타입에 의해서 결정된다.

// ------------------
// 변수 선언문
// = 자바스크립트에게 데이터를 알리는 문
// -	우변에 있는 값을 좌변에 할당 ( x = 100)
// -	쓰레기 값 = 이전에 할당 된 값이 재 할당이 되면 기존 값은 undefined로 교체 된것.
// -	가비지 컬랙터 = 쓰레기 값을 청소하는 역할

// 상수
// = 변수의 반대말. 즉 재 할당이 불가능한 변수를 가르키는 말

// Var = function scoped
// Let, const = block scoped

// 생성자, 클래스 = 카멜케이스
// 변수 > 모든 알파벳이 대문자 = 상수 선언

// 식별자
// = 값을 구분할 수 있는 고유한 이름으로 선언(declaration)으로 자바스크립트 엔진에 식별자를 알린다. . (변수, 함수, 클래스에도 존재한다) 식별자를 변수 명보다 큰 개념을 가진다.

// 변수명은 Execution Context의 Lexical Environment에 등록 된다. 실행 컨택스트는 실행 가능한 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 관리한다. (자바스크립트 엔진은 실행 컨택스트를 통해 식별자와 스코프를 관리한다)

// 변수는 런타임(run-time)이 아닌 Parsing-time에 먼저 실행된다.

// 자바스크립트 엔진은 run time이전에 소스 코드를 할줄씩 모두 평가한다. 이때 모든 선언문을 찾아 식별자를 등록하고, 초기화한다. 그후 변수, 함수 선언문을 제외한 코드를 한줄씩 리뷰 한다.

// 변수 호이스팅
// = 선언문이 코드 선두로 끌어 올려진 것처럼 동작하는 특징으로 A의 변수 선언문보다 A 콘솔이 먼저 나오면 Undefined가 찍힌다. (Var, let, const, function, class, 변수, 함수, 클레스에 모두 적용된다)

// Value Assignment
// Value는 = 연산자를 통해 우변에서 좌변으로 할당한다.

// Statement
// Variable declaration and assignment can express by one statement

// Var Item = “book”
// 선언 = run-time 이전 (Var Item)
// 할당 = runtime 이후 (“book”)
// = 선언과 할당은 다른 프로세스로서, 다른 메모리 셀을 사용한다.

// Unmanaged / managed Language
// Unmanaged L ( c )
// 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc(), free()같은 저수준 메모리 관리 기능을 제공한다. 이는 최적에 퍼포먼스를 확보하지만, 치명적인 에러를 발생시킬 위험이 있다.
// Managed L (JS)
// 메모리 접근은 제공하지 않고 자동으로 제어해준다. 이는 가비지 컬랙터가 일을 대신 수행 해준다. 퍼포먼스는 떨어지지만 일정한 생산성과 안전하게 사용이 가능하다.

// 식별자 네이밍 규칙
// -	특수문자를 제와한 문자, 숫자, underscore( _ ), 달러 기호($)
// -	시작은 특수문자, 숫자를 제외한 underscore ( _ ), 달러 기호($)만 사용 가능하다
// -	예약어는 식별자로 사용할 수 없다
// -	목적을 쉽게 이해할 수 있도록 의미를 명확이 표현해야한다.
// -	일반적으로 뱐수, 함수는 카멜 케이스, 생성자 함수, 클래스는 파스칼 케이스를 사용한다

// ------------------
//  # 데이터 타입
// 데이터 타입
// 1. 데이터 타입이란 무엇인가? 왜 필요한가?
// 데이터 타입(Data type = 타입)은 값의 종류를 말한다. 자바스크립트는 모든 값을 데이터 값을 가지고 있다.

// 1.1 데이터 타입에 의한 메모리 공간의 확보
// 프로그래밍을 하기 위해 사용되는 메모리는 저장하고 참조할 수 있어야 한다. 우선 적으로 몇 byte의 메모리 공간을 저장할 수 있는지 알아야 확보해야 할 메모리 크기를 결정할 수 있다.

// 1.2 데이터 타입에 의한 값의 해석
// 데이터 타입은 메모리 공간의 주소를 찾아가야 하기 때문에 매우 중요하다. 그렇지만 왜 중요할까?

// 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
// 값을 참조할 때 한번에 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해
// 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해
// 2. 값
// 값(value)은 더이상 평가할 수 없는 하나의 표현식이다. 즉 새로운 값에 정의가 명확해진 것으로 하나의 값으로 메모리 공간 자체를 말한다.

// 3. 값의 생성
// 값은 리터럴 표기법을 사용하며, 다양한 방법으로 표현, 생성할 수 있다.

// 리터럴(Literal)
// 소스코드 안에 리터럴 표기법으로 생성한 직접 만들어 낸 고정된 값 자체를 말한다.

// 3.1.1 리터럴 표기법을 통한 값의 생성
// 리터럴 표기법(Literal notation)은 값을 생성하는 가장 기본적인 방식으로 의미를 가지고 있는 값에 최소 단위이다.

// 다양한 타입 값(숫자, 문자열, 불리언, null, undefined, 객체, 배열, 함수, 정규 표현식 등)을 가지고 있으며 자유롭게 생성할 수 있다.

// // 정수 리터럴
// 100
// // 부동 소숫점 리터럴
// 10.5
// // 2진수 리터럴(0b로 시작)
// 0b01000001
// // 8진수 리터럴(ES6에서 도입. 0o로 시작)
// 0o101
// // 16진수 리터럴(ES6에서 도입. 0x로 시작)
// 0x41

// // 문자열 리터럴
// 'Hello'
// "World"

// // 불리언 리터럴
// true
// false

// // null 리터럴
// null

// // undefined 리터럴
// undefined

// // 객체 리터럴
// { name: 'Lee', gender: 'male' }

// // 배열 리터럴
// [ 1, 2, 3 ]

// // 함수 리터럴
// function() {}

// // 정규표현식 리터럴
// /ab+c/
// 3.2.2 값과 리터럴의 관계
// var score = 100;
// 더 이상 평가할 수 없는 리터럴이자 변수에 할당할 수 있는 값이면서 리터럴에 조건에 충족한다.

// var scroe = 50 + 50;
// 연산자를 이용해 값을 생성하는 문을 표현식(expression)이라고 한다. 리터럴 값으로 가장 기본적으로 최소 값을 가지고 있다.

// 3.2 표현식
// 표현식(expression)은 리터럴, 식별자(변수명, 함수명 등), 연산자, 함수 호출등의 조합을 말한다. 즉 하나의 값으로 평가될 수 있는 문(statement)이다.

// // 리터럴 표현식
// 10
// 'Hello'

// // 식별자 표현식
// sum
// person.name
// arr[1]

// // 연산자 표현식
// 10 + 20
// sum = 10
// sum !== 10

// // 함수/메소드 호출 표현식
// square()
// person.getName()
// 4. 데이터 타입의 분류
// ES6 기준 자바스트립트는 7개읠 데이터 타입을 제공하며 1개의 객체 타입을 포함한다.

// 원시타입 (primitive type)

// 숫자 (number) 타입: 숫자(정수, 실수)
// 문자영 (string) 타입: 문자열
// 불리언 (bloolaam) 타입: 논이적 참 / 거짓
// undefined 타입: 선언은 되었지만 값이 없는 변수에 암묵적으로 할당되는 값
// null 타입: 값이 없다는 것을 의도적으로 명시할 값
// symbol 타입: ES6에서 새롭게 추가된 7번째 타입
// 객체 타입 (object / reference type): 객제, 함수, 배열등

// 데이터는 보기에 같아도 목적이 다르며, 저장되는 메모리에 크기도 다를수 있다.

// 5. 숫자 타입
// ECMAScript 따라 숫자 타입은 64비트 부동소수점 형식(double-precision 64-bit floting-point: -(2^52 -1)~2^53 -1 사이의 숫자 값)을 따른다. 즉 실수로 표현하기 때문에 정수 표현이 어렵다.

// 정수로 되고, 정수로 표시 한다고 해도, 자바스크립트는 그 숫자를 실수로 받아들여서 연산시 정확한 값을 도출하기 어렵다.

// 숫자 타입은 3가지 특별한 값을 표현이 가능하다

// Infinity: 양의 무한대
// -Infinity: 음의 무한대
// NaN: 산술 연산 불가 (Not-a-Number)
// – 자바스크립트는 대소문을 구별 하므로 에러에 주의한다.
// 6. 문자열 타입
// 문자열(string) 타입은 텍스트 데이터를 나타내는데 사용된다.

// 문자열을 생성할 때는 작은 따옴표(‘ ‘), 큰 따옴표(“ “), 또는 배틱 ()안에 문자열을 넣는다. 자바스크립트에서는 일반적으로 작은 따옴표를 쓰는 것을 권장하며, 암묵적인 룰로 작용하고 있다.

// 자바스크립트에서 문자열은 원시 타입으로 변경이 불간능한 값(immutable value)이다. 즉 문자열이 한번 생성되면, 그 문자열을 변경할 수 없다.

// 6.1 템플릿 리터럴
// ES6 부터 템플릿 리터럴(Template literal)이라고 불리는 문자열이 도입되었다.

// 템플릿 리터럴은 작은 따옴표와 큰 따옴표를 혼용할 수 있는 방식으로 만약 두 따옴표가 한 문장에 있다면 백틱을 사용하여 묶을수 있다.

// 또한 일반적인 문자열과 달리 문자열 사이에 공백이 적용되며, 줄 바꿈은 허용되지 않는다. 단 백슬래시()로 이스케이프 시퀀스(Escape Sequence)를 사용할 수 있다.

// 문자열은 + # + 문자열 연산자를 통해 연결할 수 있다.

// var first = 'hyun-ho';
// var last = 'Lee';

// // ES5: 문자열 연결
// console.log('My name is ' + first + ' ' + last + '.');
// 하지만

// 탬플릿 리터럴은 연산자를 사용하지 않아도 문자열을 삽입할 수 있는대 이를 문자열 인폴레이션(String Interpolation)이라 한다.

// var first = 'hyun-ho';
// var last = 'Lee';

// // ES6: 문자열 연결
// console.log('My name is ${first} ${last}.');
// 문자열 인터폴레이션은 \${expression}으로 표현식을 감싼다. 단 이때 문자열을 타입으로 변환된다.

// 7. 불리언 타입
// 불리언(boolean)타입의 값은 논리적 참(true)와 거짓(false)으로 나눈다. 주로 프로그램에 흐름을 제어하는 조전문에 사용된다.

// 8. Undefined 타입
// 선언 이후 명시적으로 값을 할당하지 않는 변수는 자바스트립트 엔진의 의해 암묵적으로 초기화 되는데 이때 값이 undefined 값을 가진다. 즉 값이 할당이 되지 않은 변수에 접근하면 undefined가 반환된다.

// 9. Null 타입
// 10. Symbol 타입
// 11. 객체 타입
// 12. 동적 타이핑
// typeof 연산자
// 변수에 할당된 값의 데이터 타입을 반환한다.

// 12.1 동적 타입 언어와 정적 타입 언어
// 정적 타입(Static/Strong type)언어는 변수를 선언할 때 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언(Explicit type declaration)이라 한다

// 정적 타입 언어는 변수 타입을 변경할 수 없으며, 선언한 타입에 값만 할당할 수 있다. 타입이 맞지 않으면 실행 차제를 막기 때문에 안정적으로 코드를 구현하고 런타임 에러를 줄일수 있다.

// 정적 타입 언어는 C, C++, java, Kotlin, Go, Haskell, Rust, Scala 등이 있다.

// 12.2 동적 타입 언어와 변수
// 동적 타입(Dynamic typing)언어는 변수를 선언할 때 데이터 타입을 자유롭게 할당할 수 있다. 동적 타입에 언어는 변수 선언이 아닌 할당에 의해 결정된다.즉 재할당에 의해 변수의 타입은 언제든지 변경할 수 있다.

// 그렇지만 복잡한 프로그램에서 동적 변화 데이터는 추적이 어렵고, 의도치 않은 충동을 만들어 낼수 있다. 또한 데이터 저장 값을 확인하기 전까지 값을 확신할 수 없다.

// 결국 동적 타입 언어는 유연성(flexibility)은 높지만 신뢰성(reliabiity)은 떨어진다

// ------------------
//  # 제어문
// 제어문 (Control flow statement)
// 코드의 실행 순서를 인위적으로 제어할 수 있으며(가독성이 떨어지고 오류를 발생시킨다) 일반적으로 코드는 위에서 아래로 순차적으로 신행된다. 주어진 조건에 따라 코드를 실행하거나 반복 실행한다.

// 1. 블록문 (Block statement / Compound statement)
// 0개 이상의 문을 중괄호({})로 묶은 것으로 블록(코드 블록)이며 이는 하나에 실행 단위를 갖는다. 즉 같이 실행된다는 뜻을 가지고 있다.

// 블록문은 단독으로 사용이 가능하지만, 제어문이나 함수 선언문에 주로 사용한다. 문의 끝에 세미 콜론(;)을 옵션으로 붙이는 것이 가능하다.
// 2. 조건문 (Conditional statement)
// 조건식 (conditional expression)은 불리언 값으로 평가되고 그 결과에 따라 코드 블럭의 실행을 결정한다.

// 2.1. if…else 문
// 참, 거짓에 따라 실행할 코드 블록을 결정하고 결과 값이 불리언이 아니라면 강제적으로 논리적 참과 거짓을 구별한다.

// 2.2. switch 문
// 주어진 표현문을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동 시킨다. case을 의미하는 표현식이 끝난 후 콜론으로 마친다. 여기서 일치하는 표현식이 없다면 실행 순서는 default 문으로 이동한다 (default는 옵션으로 없다면 다음 case로 넘어간다). Switch는 조건이 많을때 사용한다.

// 3. 반복문 (Loop statment)
// 주어진 조건에 결과가 참일 경우만 실행한다. 반복문은 조건이 거짓이 될때까지 무한 반복 된다(시스템, 메모리 에러가 경우 실행이 중지 될수 있다).

// 3.1 for 문
// for (변수 선언 또는 할당; 조건식; 증감식) {
// 실행 구문
// }

// 4. Break 문
// 블록 코드는 모드 제어문 환경에서 코드 탈출을 할 수 없다. 레이블 문, 반복문, switch 문의 코드 블록을 탈출한다. 코드 블록 이외에 break 문을 사용하면 syntaxError(문법에러)가 발생한다.

// 5. Continue 문
// 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다.

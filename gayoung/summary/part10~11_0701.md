### TIL(2019.07.01) poiemaweb part10 ~ part11

## 10. **원시 값과 객체의 비교**

### 1. 원시값 : 변경 불가능한 값(immutable value)

#### [ 변경 불가능한 값 ]

-  원시 값을 갖는 변수에 새로운 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한다. 
- 변수가 참조하던 메모리 공간의 주소를 변경한 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 
-  단, ECMAScript 사양에 원시 타입의 크기를 규정하고 있지는 않다.    원시 타입의 크기는 브라우저 제조사의 구현에 따라 다를 수 있다.
- `str[0] = 'S'`처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다. 이때 에러가 발생하지 않는다



#### [유사 배열 (Array-like Object) ] 

유사 배열은 배열은 아니지만 마치 배열처럼 처리할 수 있는 객체를 말한다. 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며 for 문으로 순회할 수도 있다. 이는 문자열이 length 프로퍼티를 갖는 객체일 수 있음을 의미한다.
갑자기 원시 값이 객체일 수도 있다니 혼란스러울 수 있겠다. 아직 살펴보지 않았지만 원시 값을 객체처럼 사용하면 원시 값을 감싸는 객체로 자동 변환된다. 이를 위해 String, Number, Boolean 등의 생성자 함수가 존재한다. 



#### [ 값에 의한 전달 (Pass by value) ]

```
var foo = 10;

// 변수 bar에는 변수 foo의 값 10이 복사되어 할당된다.
var bar = foo;

console.log(foo, bar);    // 10  10
console.log(foo === bar); // true

// 변수 foo와 변수 bar의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 변수 foo의 값을 변경하여도 변수 bar의 값에는 어떠한 영향도 주지 않는다.
foo = 100;

console.log(foo, bar);    // 100  10
console.log(foo === bar); // false
```

- 원시 타입의 값은 다른 메모리 공간에 복사되어 전달
- 따라서 foo값과 bar값은 각기 다른 메모리공간에 저장



### 2. 객체 (mutable value)

```
// 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};
// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 추가
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}

```



- 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 
- 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- Java와 같은 클래스 기반 객체 지향 프로그래밍 언어의 객체 관리 방식보다 더 비용이 많이 드는 비효율적인 방식이다. 따라서 V8 자바스크립트 엔진은 히든 클래스(hidden class)라는 방식을 사용한다. 
- , 객체를 할당한 변수는 **참조 값(Reference value)**을 값으로 갖는다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다.

```
- 얕은 복사(shallow copy)와 깊은 복사(deep copy)
참조 값을 복사하는 것을 얕은 복사(shallow copy) 
원시 값처럼 객체 자체를 복사를 깊은 복사(deep copy)
```



#### [ 참조에 의한 전달(Pass by reference) ]



## 11.함수

```
// 함수 정의
function add(x, y) {
  return x + y;
}
// 함수 호출
var result = add(2, 5);

// 함수 add에 인수 2, 5를 전달하면서 호출하면 7을 반환한다.
console.log(result); // 7
```
- 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메소드, this, 프로토타입, 모듈화와 관련
- 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)
- 함수 정의만으로 함수는 실행되지 않는다. 수학의 함수처럼 미리 정의된 일련의 과정을 실행하기 위해 필요한 입력, 즉 인수(argument)를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 지시해야 한다. 이를 **함수 호출(Function call/invoke)**이라 한다. 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 결과를 반환한다.
- 함수는 몇 번이든 호출할 수 있으므로 **코드의 재사용**이라는 측면에서 매우 유용
-  **함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가**



#### [함수 리터럴]

- 함수 리터럴이 평가되어 생성된 객체 즉 값을 변수에 할당

- 함수는 객체

  - 함수명은 몸체 내에서만 참조할 수 있는 식별자, 생략 가능
  - 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분
  - 매개변수에는 인수가 할당
  - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급

  - 함수호출에 의해 실행

  

#### [ 함수 선언문 (Function Declaration/Function Statement) ]

```
function add(x, y) {
  return x + y;
}
```

- 함수 선언문은 실행되어 함수 객체를 생성

#### [ 함수 표현식(Function Expression) ]

#### [ Function 생성자 함수(Function Constructor) ]

#### [ 화살표 함수(Arrow Function): ES6 ]








# day04.

## 스코프(Scope)
* 스코프는 유효범위를 말하며, 변수 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위를 말한다.

```
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x);  // local

foo();

console.log(x); // global
```
* 위의 예제에서 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지를 결정하는걸 알 수 있다.
* 스코프란 자바스크립트 엔진이 참조할 변수를 검색할때 사용하는 규칙이다.
* var키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
* let, const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
```
function bar() {
  let x = 1;
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
}
bar();
```
* 스코프는 전역스코프와 지역 스코프로 구분할 수 있다.
* 변수는 자신이 선언된 위치에 의해 자신의 유표 범위 스코프가 결정되기 때문에 전역에 선언된 변수는 전역 스코프를 갖고, 지역에서 선언된 변수는 지역스코프를 갖는다.
* 전역변수는 어디서든지 참조할 수 있기 때문에 함수 내부에서도 참조할 수 있다.
* 지역변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.
* 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다.

### 스코프 체인
* 함수의 몸체 내부에서 함수가 정의된 것을 중첩함수라 하며, 중첩함수를 포함하는 함수를 외부함수라고 부른다.
* 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다.
* 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.
* 변수를 참조할때, 자바스크립트엔진은 스코프체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 
* 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.
* 스코프체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 상속과 유사하다. 부모의 자산을 자식이 자유롭게 사용할 수 있지만 부모는 자식의 자산을 사용할 수 없다.

### 함수레벨스코프
* 코드블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.
* 함수몸체 만이 아니라 모든 코드블록(if,for,while,try/catch등)이 지역 스코프를 만드는데 이러한 특성을 블록 레벨 스코프라고 한다.
* var 키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역스코프로 인정하는데 이런걸 함수레벨 스코프라한다.

### 렉시컬 스코프
* 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 것을 말한다.
* 동적 스코프는 함수를 어디서 호출했는지에 따라 상위 스코프를 결정하는것 
* 렉시컬스코프는 함수를 어디서 정의했는지에 따라 상위 스코프가 결정되므로 모든 함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 스코프를 기억한다.
* 함수가 호출되면 언제나 자신이 기억하고 있는 자신이 정의된 스코프를 상위 스코프로 사용한다. 함수가 호출된 위치는 함수 자신이 기억하고 있는 스코프, 즉 상위 스코프 결정에 어떠한 영향을 주지 않는다.


## 암묵적 전역변수
* 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역 변수를 선언하고 값을 할당한다.
* 선언하지 않은 변수에 값을 할당하는 것은 문법적으로 허용되지만 의도하지 않게 암묵적 전역 변수를 생성하고 이로 인해 전역 변수가 중복 선언될 수 있다.
* 자바스크립트는 변수의 중복 선언을 허용하므로 어떠한 에러도 발생하지 않고 무한 반복 상태에 빠지게 될 수 있다.

## 전역변수의 문제점
* 변수는 선언에 의해 생성되고 할당을 통해 값을 갖으며 언젠가 소멸한다. 이러한 것을 변수의 생명주기라고 한다.
* 변수는 자신이 선언된 위치에서 생성되고 소멸한다. 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.
* 변수 선언은 런타임에 실행되는 것이 아니라, 런타임 이전에 자바스크립트엔진에 의해 먼저 실행된다.
* 변수 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.

## 전역변수의 대표적 문제점
1. 암묵적 결합 
- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합이 되기 때문에 의도치 않게 상태가 변경될 수 있는 위험성이 있다.
2. 긴 생명주기 
- var 키워드는 중복 선언이 가능하므로 생명주기가 길어서 변수명이 중복되면 의도치 않은 재할당이 이루어진다.
3. 스코프 체인 상에서 종점에 존재
- 전역변수의 검색 속도가 가장 느리다 
4. 네임 스페이스 오염
- 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

## 전역 변수 사용 억제 방법
* 전역변수를 반드시 사용할 이유를 찾지 못한다면 가급적 생명주기가 짧은 지역변수를 사용하는게 좋고, 변수의 스코프는 좁을수록 좋다.

1. 즉시 실행함수
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
2. 네임 스페이스 객체
- 전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법. 네임 스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않다.
3. 모듈패턴
- 클래스를 모방하여 관련이 있는 변수와 함수를 모아서 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것을 말한다.
- 모듈패턴은 외부에 공개될 필요가 없는 정보를 숨기는 정보 은닉이라고도 한다. 
4. es6 모듈



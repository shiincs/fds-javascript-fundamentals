# 1. Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.
- 생성자(constructor) 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 개게를 인스턴스(instance)라 한다.
- 인스턴스(instance) : 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어이다. 생성자 함수도 객체이기 때문에 생성자 함수나 클래스가 생성한 객체를 다른 객체와 구분하기 위해 인스턴스라고 부른다.

# 2. 생성자 함수
## 2.1. 객체 리터럴에 의한 객체 생성 방식의 문제점
- 객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼틱를 갖는 객체를 여러개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다

## 2.2. 생성자 함수에 의한 객체 생성 방식의 장점
- 생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.
- 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

## 2.3. 내부 메소드 [[Call]]과 [[Constructor]]
- 내부 메소드 [[Call]]이 구현되어 있는 객체를 callable이라 하며, 내부 메소드인 [[Constuctor]]이 구현되어 있는 객체를 constructor, [[Constructor]]가 구현되어 있지 않은 객체를 non-constructor라고 부른다
- callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 생성자 함수로서 호출할 수 있다는 것은 new 연산자(또는 super 연산자)와 함께 호출하는 것을 의미한다.
- 호출할 수 없는 객체는 함수 객체가 아니므로 함수로서 기능하는 객체, 즉 함수 객체는 반드시 callable이여야 한다. 따라서 모든 함수 객체는 [[Call]]이 구현되어 있어 호출할 수 있다. 하지만 모든 함수 객체가 [[Constuctor]]를 구현하지는 않는다. 다시 말해, 함수 객체는 constructor일 수도 있고 non-constructor일 수 있다.
- 결론적으로 함수 객체는 callable이면서 constuctor이거나 callable 이면서 non-constuctor이다. 즉, 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.
- super 키워드 : super는 ES6에서 도입된 클래스에서 부모 클래스를 참조(this와 유사하다) 할 때 또는 부모 클래스의 생성자(constructor)를 호출할 때 사용한다.

## 2.4. constructor와 non-constuctor의 구분
- 일반적으로 프로퍼티의 값인 함수는 모두 메소드로 통칭한다. 함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다.
- 일반 함수로 정의된 함수만이 constructor이다. 함수의 종류가 Arrow,Method인 함수는 non-constructor가 된다. 일반 함수로 정의된 함수 만이 생성자 함수로서 호출될 수 있다.
- 함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자 또는 super 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Constructor]]가 호출된다.
- non-constructor인 함수 객체는 내부 메소드 [[Constructor]]가 구현되어 있지 않다. 따라서 non-constructor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다.
- 생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다.

## 2.5. 생성자 함수의 동작 방식
- 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스 프로퍼티 값을 초기화 하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스의 프로퍼티 값을 초기화하는 것은 옵션이다.

## 2.6 new 연산자
- 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다.
- 생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다.

## 2.7. new.target
- new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.
- new.target은 함수 내부에서 지역 변수와 같이 사용되며 메타 프로퍼티(meta property) 라고 부른다. IE는 new.target을 지원하지 않으므로 주의하기 바란다.
- 함수 내부에서 new.target을 사용하면 함수가 new 연산자와 함께 호출되었는지 여부를 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다.